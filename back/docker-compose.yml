services:
  app:
    build:
      context: .  # Directorio de contexto para la construcción de la imagen
      dockerfile: Dockerfile  # Archivo Dockerfile a utilizar
      target: app  # Usamos la etapa "app" del Dockerfile
    container_name: plantcare-backend  # Nombre del contenedor para la aplicación
    ports:
      - "5000:5000"  # Mapeo de puertos: puerto 5000 del host al puerto 5000 del contenedor
    volumes:
      - api_data:/app/data  # Volumen para persistir datos de la aplicación
      - uploads_data:/app/uploads  # Volumen para persistir archivos subidos (avatars, etc.)
    networks:
      - app_network  # Red a la que pertenece el contenedor
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "--fail", "http://localhost:5000/api/health"]  # Comando para verificar la salud del servicio
      interval: 1m  # Intervalo entre verificaciones de salud
      timeout: 10s  # Tiempo de espera para que la verificación de salud se complete
      retries: 3  # Número de intentos antes de considerar el servicio no saludable
    restart: always  # Política de reinicio del contenedor
    env_file:
      - .env  # Archivo de variables de entorno a cargar
    environment:
      # Sobrescribir variables de DB para usar el servicio de postgres
      - DB_HOST=postgres
      - DB_PORT=5432
      - REDIS_URL=redis://redis:6379

  postgres:
    image: postgres:15-alpine  # Imagen de PostgreSQL a utilizar
    container_name: plantcare-postgres  # Nombre del contenedor para PostgreSQL
    environment:
      - POSTGRES_USER=${DB_USER:-postgres}  # Usuario de PostgreSQL desde .env
      - POSTGRES_PASSWORD=${DB_PASSWORD}  # Contraseña de PostgreSQL desde .env
      - POSTGRES_DB=${DB_DATABASE:-plantcare_db}  # Base de datos desde .env
      - PGDATA=/var/lib/postgresql/data/pgdata  # Directorio de datos de PostgreSQL
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Volumen para persistir datos de PostgreSQL
    ports:
      - "5432:5432"  # Mapeo de puertos: puerto 5432 del host al puerto 5432 del contenedor
    networks:
      - app_network  # Red a la que pertenece el contenedor
    restart: always  # Política de reinicio del contenedor
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]  # Comando para verificar la salud del servicio PostgreSQL
      interval: 10s  # Intervalo entre verificaciones de salud
      timeout: 5s  # Tiempo de espera para que la verificación de salud se complete
      retries: 5  # Número de intentos antes de considerar el servicio no saludable
      start_period: 10s  # Tiempo de espera antes de comenzar las verificaciones de salud

  redis:
    image: redis:7-alpine  # Imagen de Redis a utilizar
    container_name: plantcare-redis  # Nombre del contenedor para Redis
    ports:
      - "6379:6379"  # Mapeo de puertos: puerto 6379 del host al puerto 6379 del contenedor
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data  # Volumen para persistir datos de Redis
    networks:
      - app_network  # Red a la que pertenece el contenedor
    restart: always  # Política de reinicio del contenedor
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]  # Comando para verificar la salud del servicio Redis
      interval: 10s  # Intervalo entre verificaciones de salud
      timeout: 3s  # Tiempo de espera para que la verificación de salud se complete
      retries: 5  # Número de intentos antes de considerar el servicio no saludable
      start_period: 5s  # Tiempo de espera antes de comenzar las verificaciones de salud

networks:
  app_network:
    name: app_network  # Nombre de la red
    driver: bridge  # Driver de red a utilizar

volumes:
  api_data:
    name: plantcare_api_data  # Nombre del volumen para datos de la aplicación
    driver: local  # Driver de volumen a utilizar
  postgres_data:
    name: plantcare_postgres_data  # Nombre del volumen para datos de PostgreSQL
    driver: local  # Driver de volumen a utilizar
  uploads_data:
    name: plantcare_uploads_data  # Nombre del volumen para archivos subidos
    driver: local  # Driver de volumen a utilizar
  redis_data:
    name: plantcare_redis_data  # Nombre del volumen para datos de Redis
    driver: local  # Driver de volumen a utilizar

